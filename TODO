 ☐ Integration with django-haystack to provide search indexes to facilitate filtering
 ✔ Underscorize class names in our attempt to name ourselves @done (13-01-25 13:24)
 ✔ Resolving arbitrary URLs @done (13-01-18 20:38)
 ✔ POST @done (13-01-25 12:59)
 ✔ PUT @done (13-01-25 13:23)
 ☐ PATCH
 ✔ DELETE @done (13-01-18 22:55)
 ✔ OPTIONS @done (13-01-18 16:16)
 ✔ Header: Link @done (13-01-25 13:24)
     ✔ Automatic generation of link headers for related resources @done (13-01-25 13:24)
     ☐ Ability to add additional link headers through like a 'links' option
 ☐ Header: Link; rel="schema"
     This is going to require a small RFC to accompany it.
     ✔ We can remove the resource_uri property now @done (13-01-25 13:25)
 ☐ Headers: Range / Content-Range
     Pagination. This will have to firmly integrated into the base resources (
     perhaps in View) as it will need to make successive calls to dispatch to
     get multiple ranges.
 ☐ Query parsing
     We really need to get a specification describing this.
     ☐ OR changes: ?this=x;this=y;that=z  this is x OR this is y OR that is z
     ✔ '.' instead of'__' @done (13-01-18 22:57)
     ☐ Refactor as a state machine to allow for arbitrarily complex queries
           eg. /poll?question='/choice/1/choice_text' would grab every poll with
           the same text as the choice #1's choice_text -- another example is
           /user?instance(owner)=True would get every owner of an instance
           Keep in mind this is just the parsing
 ☐ Filtering
     ✔ Applying the query @done (13-01-18 23:29)
     ☐ Ensuring non-filterable properties are not filterable
         This has to actually traverse and ask each resource if it can be
         filtered by the property in question
     ☐ Allow configuring what properties can be filtered by a 'filtering' prop
 ☐ Sorting
     ✔ Applying the query @done (13-01-18 23:29)
     ☐ Ensuring non-sortable properties are not sortable
     ☐ Allow configuring what properties can be sorted by a 'ordering' prop
 ☐ Sub-resource navigation
     ☐ Traversal (resource navigation)
         The actual traversal method is done; just need some tests and some
         bugs worked out.
     ☐ Navigation
         Basically `/poll/1/choices/` should only return the choices for
         the poll in question.
 ☐ Authorization
     Most of this work is done; we just need to work out some bugs and invoke
     it appropriately (most importantly for cases like creating an object).
 ☐ Authentication
     ✔ Basic @done (13-01-18 23:07)
     ☐ Digest
     ☐ OAuth 1
     ☐ OAuth 2
     ☐ SAML Client
     ☐ Django session/cookie
     ☐ Generic token (perhaps?)
 ☐ Configuration
     ☐ Turning off data being returned from PUT / POST / PATCH
     ☐ Turning off validation
     ☐ Changing the field name of the slug
         Right now it will always be pk; there is a make_slug method but is
         broken because if you try and do /poll/3910 it will still only
         try the PK. `slug_attribute = "pk"` might work though its a long name.
 ✔ Transactional requests @done (13-01-25 12:58)
     Begin, commit, and rollback methods (or similar) should (inside model.py)
     facilitate a database transaction
 ☐ Policies
     General abstract idea that could be used to implement throttling.
     I'm thinking something like a small rules engine that can govern the
     API. I don't (right now) see any use for a policy besides throttling so
     we could reduce the scope to just throttling but I would still like a
     declarative way to specify that a resource should be throttled to 15 calls
     every 30 minutes per user or perhaps the call limit is determine by a
     user property to allow for use tiers.
 ☐ Relation resolution
     Specifies to use while creating / updating to speficiy what related resource
     ✔ Reference through slugs @done (13-01-25 12:59)
     ✔ Reference through URI @done (13-01-25 12:59)
     ☐ Create inline
 ☐ Browser side Cacheing
     Basically I mean just faciltiating this through ETag, Last modified dates,
     etc.
 ☐ Through reference; referencing properties from the relationship between two resources
     /team/5/user?(owner)=true   all owners of team 5
 ☐ Set specifiers
     /team/1,2 will return both teams 1 and 2
     /team/10-20 will return teams 10 through 20
     /team/<format> will mirror the HTTP RANGE header request syntax without the `items=` portion
     /apple,orange will return all apples and oranges using a base class resource (if available) or 400
 ☐ Plucking
     By 'plucking' we mean that if there is a resource called 'Apple' with a
     property 'color'; then `GET /apple/color` will get an array of all colors
     for every apple.
 ☐ URL segment filtering
     /apple:<query>   query mirrors the query string format without sorting and includes implied booleans
     /apple:color=red/core  selects all cores of all apples that are red
     /apple:color!asc selects all apple sorted asc by color
 ☐ Decoders
     ☐ Text (plain/text)
     ☐ Form (multipart/form-data)
     ☐ Url (application/x-www-form-urlencoded)
     ☐ Xml (application/xml)
     ✔ Json (application/json) @done (13-01-25 11:24)
     ☐ Yaml
     ☐ Binary (perhaps messagepack ?)
     ☐ Direct (pass-through, as-in, an image file)
 ☐ Encoders
     ☐ Text (plain/text)
     ☐ Form (multipleltipart/form-data)
     ✔ Json (application/json) @done (13-01-25 11:24)
     ☐ Xml (application/xml)
     ☐ Yaml
     ☐ Binary (perhaps messagepack ?)
     ☐ Direct (pass-through, as-in, an image file)
 ☐ Publish / Subscribe messages for push notifications
     Something like https://code.google.com/p/pubsubhubbub/ was.. (its dead now)
    ☐ Link header pointing to the hub ?
    ☐ Ability to POST listeners
    ☐ Ability to DELETE listeners
    ☐ Ability to create a listener with web-sockets or something... ?
 ☐ More on web-sockets; the ability to create a persistent connection
 ☐ Simple HTTP streaming support to stream huge responses to the client
